// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Js_json = require("rescript/lib/js/js_json.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");
var Caml_option = require("rescript/lib/js/caml_option.js");

function fromString(s) {
  try {
    return Caml_option.some(JSON.parse(s));
  }
  catch (exn){
    return ;
  }
}

function toString(prim) {
  return JSON.stringify(prim);
}

function optToRes(option, err) {
  if (option !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: Caml_option.valFromOption(option)
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: err
          };
  }
}

function resMapError(res, f) {
  if (res.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: res._0
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: Curry._1(f, res._0)
          };
  }
}

var Utils = {
  optToRes: optToRes,
  resMapError: resMapError
};

function string(j) {
  return optToRes(Js_json.decodeString(j), {
              TAG: /* Failure */0,
              _0: "invalid string",
              _1: j
            });
}

function bool(j) {
  return optToRes(Js_json.decodeBoolean(j), {
              TAG: /* Failure */0,
              _0: "invalid bool",
              _1: j
            });
}

function $$int(j) {
  return optToRes(Belt_Option.map(Js_json.decodeNumber(j), (function (prim) {
                    return prim | 0;
                  })), {
              TAG: /* Failure */0,
              _0: "invalid int",
              _1: j
            });
}

function $$float(j) {
  return optToRes(Js_json.decodeNumber(j), {
              TAG: /* Failure */0,
              _0: "invalid float",
              _1: j
            });
}

function array(aDecoder) {
  return function (j) {
    return Belt_Result.flatMap(optToRes(Js_json.decodeArray(j), {
                    TAG: /* Failure */0,
                    _0: "invalid array",
                    _1: j
                  }), (function (arr) {
                  return arr.reduce((function (acc, cur, index) {
                                if (acc.TAG !== /* Ok */0) {
                                  return acc;
                                }
                                var error = Curry._1(aDecoder, cur);
                                if (error.TAG === /* Ok */0) {
                                  return {
                                          TAG: /* Ok */0,
                                          _0: acc._0.concat([error._0])
                                        };
                                } else {
                                  return {
                                          TAG: /* Error */1,
                                          _0: {
                                            TAG: /* Index */1,
                                            _0: index,
                                            _1: error._0
                                          }
                                        };
                                }
                              }), {
                              TAG: /* Ok */0,
                              _0: []
                            });
                }));
  };
}

function dict(aDecoder) {
  return function (j) {
    return Belt_Result.map(Belt_Result.flatMap(optToRes(Js_json.decodeObject(j), {
                        TAG: /* Failure */0,
                        _0: "invalid object",
                        _1: j
                      }), (function (obj) {
                      return Js_dict.entries(obj).reduce((function (acc, param) {
                                    var key = param[0];
                                    if (acc.TAG !== /* Ok */0) {
                                      return acc;
                                    }
                                    var error = Curry._1(aDecoder, param[1]);
                                    if (error.TAG === /* Ok */0) {
                                      return {
                                              TAG: /* Ok */0,
                                              _0: acc._0.concat([[
                                                      key,
                                                      error._0
                                                    ]])
                                            };
                                    } else {
                                      return {
                                              TAG: /* Error */1,
                                              _0: {
                                                TAG: /* Field */2,
                                                _0: key,
                                                _1: error._0
                                              }
                                            };
                                    }
                                  }), {
                                  TAG: /* Ok */0,
                                  _0: []
                                });
                    })), Js_dict.fromArray);
  };
}

function keyValuePairs(aDecoder) {
  return function (j) {
    return Belt_Result.flatMap(optToRes(Js_json.decodeObject(j), {
                    TAG: /* Failure */0,
                    _0: "invalid object",
                    _1: j
                  }), (function (obj) {
                  return Js_dict.entries(obj).reduce((function (acc, param) {
                                var key = param[0];
                                if (acc.TAG !== /* Ok */0) {
                                  return acc;
                                }
                                var error = Curry._1(aDecoder, param[1]);
                                if (error.TAG === /* Ok */0) {
                                  return {
                                          TAG: /* Ok */0,
                                          _0: acc._0.concat([[
                                                  key,
                                                  error._0
                                                ]])
                                        };
                                } else {
                                  return {
                                          TAG: /* Error */1,
                                          _0: {
                                            TAG: /* Field */2,
                                            _0: key,
                                            _1: error._0
                                          }
                                        };
                                }
                              }), {
                              TAG: /* Ok */0,
                              _0: []
                            });
                }));
  };
}

function field(key, aDecoder) {
  return function (j) {
    return Belt_Result.flatMap(Belt_Result.flatMap(optToRes(Js_json.decodeObject(j), {
                        TAG: /* Failure */0,
                        _0: "invalid object",
                        _1: j
                      }), (function (obj) {
                      return optToRes(Js_dict.get(obj, key), {
                                  TAG: /* Field */2,
                                  _0: key,
                                  _1: {
                                    TAG: /* Failure */0,
                                    _0: "does not exist",
                                    _1: j
                                  }
                                });
                    })), (function (jv) {
                  return resMapError(Curry._1(aDecoder, jv), (function (e) {
                                return {
                                        TAG: /* Field */2,
                                        _0: key,
                                        _1: e
                                      };
                              }));
                }));
  };
}

function at(firstKey, keys, aDecoder) {
  return function (j) {
    return Belt_Result.flatMap(keys.reduce((function (acc, cur) {
                      if (acc.TAG !== /* Ok */0) {
                        return acc;
                      }
                      var sj = acc._0[0];
                      return Belt_Result.flatMap(optToRes(Js_json.decodeObject(sj), {
                                      TAG: /* Failure */0,
                                      _0: "invalid object",
                                      _1: sj
                                    }), (function (sObj) {
                                    return Belt_Result.map(optToRes(Js_dict.get(sObj, cur), {
                                                    TAG: /* Field */2,
                                                    _0: cur,
                                                    _1: {
                                                      TAG: /* Failure */0,
                                                      _0: "does not exist",
                                                      _1: sj
                                                    }
                                                  }), (function (ssj) {
                                                  return [
                                                          ssj,
                                                          cur
                                                        ];
                                                }));
                                  }));
                    }), {
                    TAG: /* Ok */0,
                    _0: [
                      j,
                      firstKey
                    ]
                  }), (function (param) {
                  var key = param[1];
                  return resMapError(Curry._1(aDecoder, param[0]), (function (e) {
                                return {
                                        TAG: /* Field */2,
                                        _0: key,
                                        _1: e
                                      };
                              }));
                }));
  };
}

function index(index$1, aDecoder) {
  return function (j) {
    return Belt_Result.flatMap(Belt_Result.flatMap(optToRes(Js_json.decodeArray(j), {
                        TAG: /* Failure */0,
                        _0: "invalid array",
                        _1: j
                      }), (function (arr) {
                      return optToRes(Belt_Array.get(arr, index$1), {
                                  TAG: /* Index */1,
                                  _0: index$1,
                                  _1: {
                                    TAG: /* Failure */0,
                                    _0: "out of bounds",
                                    _1: j
                                  }
                                });
                    })), (function (jv) {
                  return resMapError(Curry._1(aDecoder, jv), (function (e) {
                                return {
                                        TAG: /* Index */1,
                                        _0: index$1,
                                        _1: e
                                      };
                              }));
                }));
  };
}

function option(aDecoder) {
  return function (j) {
    return {
            TAG: /* Ok */0,
            _0: Belt_Result.getWithDefault(Belt_Result.map(Curry._1(aDecoder, j), (function (a) {
                        return Caml_option.some(a);
                      })), undefined)
          };
  };
}

function oneOf(firstDecoder, decoders) {
  return function (j) {
    var a = Curry._1(firstDecoder, j);
    if (a.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: a._0
            };
    } else {
      return resMapError(decoders.reduce((function (acc, cur) {
                        if (acc.TAG === /* Ok */0) {
                          return acc;
                        }
                        var ne = Curry._1(cur, j);
                        if (ne.TAG === /* Ok */0) {
                          return {
                                  TAG: /* Ok */0,
                                  _0: ne._0
                                };
                        } else {
                          return {
                                  TAG: /* Error */1,
                                  _0: {
                                    hd: ne._0,
                                    tl: acc._0
                                  }
                                };
                        }
                      }), {
                      TAG: /* Error */1,
                      _0: {
                        hd: a._0,
                        tl: /* [] */0
                      }
                    }), (function (es) {
                    return {
                            TAG: /* OneOf */3,
                            _0: Belt_List.toArray(es)
                          };
                  }));
    }
  };
}

function decodeString(decoder, s) {
  return Belt_Result.flatMap(optToRes(fromString(s), {
                  TAG: /* Failure */0,
                  _0: "Invalid JSON",
                  _1: s
                }), decoder);
}

function decodeValue(decoder, j) {
  return Curry._1(decoder, j);
}

function errorToString(_e) {
  return "TODO";
}

function map(decoder, f) {
  return function (j) {
    return Belt_Result.map(Curry._1(decoder, j), f);
  };
}

function map2(decoderA, decoderB, f) {
  return function (j) {
    return Belt_Result.flatMap(Curry._1(decoderA, j), (function (a) {
                  return Belt_Result.map(Curry._1(decoderB, j), (function (b) {
                                return Curry._2(f, a, b);
                              }));
                }));
  };
}

function andMap(decoderF, decoderA) {
  return map2(decoderF, decoderA, (function (f, a) {
                return Curry._1(f, a);
              }));
}

function $$null(v) {
  return function (j) {
    return Belt_Result.map(optToRes(Js_json.decodeNull(j), {
                    TAG: /* Failure */0,
                    _0: "invalid null",
                    _1: j
                  }), (function (param) {
                  return v;
                }));
  };
}

function nullable(decoder) {
  var f = function (a) {
    return Caml_option.some(a);
  };
  return oneOf((function (j) {
                return Belt_Result.map(Curry._1(decoder, j), f);
              }), [(function (j) {
                  return Belt_Result.map(optToRes(Js_json.decodeNull(j), {
                                  TAG: /* Failure */0,
                                  _0: "invalid null",
                                  _1: j
                                }), (function (param) {
                                
                              }));
                })]);
}

function andThen(decoder, f) {
  return function (j) {
    return Belt_Result.flatMap(Curry._1(decoder, j), (function (a) {
                  var b = Curry._1(f, a);
                  return Curry._1(b, j);
                }));
  };
}

function succeed(a) {
  return function (param) {
    return {
            TAG: /* Ok */0,
            _0: a
          };
  };
}

function fail(err) {
  return function (j) {
    return {
            TAG: /* Error */1,
            _0: {
              TAG: /* Failure */0,
              _0: err,
              _1: j
            }
          };
  };
}

var Decoder = {
  string: string,
  bool: bool,
  $$int: $$int,
  $$float: $$float,
  array: array,
  dict: dict,
  keyValuePairs: keyValuePairs,
  field: field,
  at: at,
  index: index,
  option: option,
  oneOf: oneOf,
  decodeString: decodeString,
  decodeValue: decodeValue,
  errorToString: errorToString,
  map: map,
  map2: map2,
  andMap: andMap,
  $$null: $$null,
  nullable: nullable,
  andThen: andThen,
  succeed: succeed,
  fail: fail
};

var J;

var B;

exports.J = J;
exports.B = B;
exports.fromString = fromString;
exports.toString = toString;
exports.Utils = Utils;
exports.Decoder = Decoder;
/* No side effect */
