// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("rescript/lib/js/curry.js");
var Js_dict = require("rescript/lib/js/js_dict.js");
var Js_json = require("rescript/lib/js/js_json.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Belt_Result = require("rescript/lib/js/belt_Result.js");
var Caml_option = require("rescript/lib/js/caml_option.js");

function optToRes(option, err) {
  if (option !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: Caml_option.valFromOption(option)
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: err
          };
  }
}

function resMapError(res, f) {
  if (res.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: res._0
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: Curry._1(f, res._0)
          };
  }
}

function string(j) {
  return optToRes(Js_json.decodeString(j), {
              TAG: /* Failure */0,
              _0: "a STRING",
              _1: j
            });
}

function bool(j) {
  return optToRes(Js_json.decodeBoolean(j), {
              TAG: /* Failure */0,
              _0: "a BOOL",
              _1: j
            });
}

function $$int(j) {
  return optToRes(Belt_Option.map(Js_json.decodeNumber(j), (function (prim) {
                    return prim | 0;
                  })), {
              TAG: /* Failure */0,
              _0: "an INT",
              _1: j
            });
}

function $$float(j) {
  return optToRes(Js_json.decodeNumber(j), {
              TAG: /* Failure */0,
              _0: "a FLOAT",
              _1: j
            });
}

function array(aDecoder) {
  return function (j) {
    return Belt_Result.flatMap(optToRes(Js_json.decodeArray(j), {
                    TAG: /* Failure */0,
                    _0: "an ARRAY",
                    _1: j
                  }), (function (arr) {
                  return arr.reduce((function (acc, cur, index) {
                                if (acc.TAG !== /* Ok */0) {
                                  return acc;
                                }
                                var error = Curry._1(aDecoder, cur);
                                if (error.TAG === /* Ok */0) {
                                  return {
                                          TAG: /* Ok */0,
                                          _0: acc._0.concat([error._0])
                                        };
                                } else {
                                  return {
                                          TAG: /* Error */1,
                                          _0: {
                                            TAG: /* Index */1,
                                            _0: index,
                                            _1: error._0
                                          }
                                        };
                                }
                              }), {
                              TAG: /* Ok */0,
                              _0: []
                            });
                }));
  };
}

function list(aDecoder) {
  return function (j) {
    return Belt_Result.flatMap(optToRes(Js_json.decodeArray(j), {
                    TAG: /* Failure */0,
                    _0: "an ARRAY",
                    _1: j
                  }), (function (arr) {
                  return Belt_Array.reverse(arr).reduce((function (acc, cur, index) {
                                if (acc.TAG !== /* Ok */0) {
                                  return acc;
                                }
                                var error = Curry._1(aDecoder, cur);
                                if (error.TAG === /* Ok */0) {
                                  return {
                                          TAG: /* Ok */0,
                                          _0: {
                                            hd: error._0,
                                            tl: acc._0
                                          }
                                        };
                                } else {
                                  return {
                                          TAG: /* Error */1,
                                          _0: {
                                            TAG: /* Index */1,
                                            _0: index,
                                            _1: error._0
                                          }
                                        };
                                }
                              }), {
                              TAG: /* Ok */0,
                              _0: /* [] */0
                            });
                }));
  };
}

function dict(aDecoder) {
  return function (j) {
    return Belt_Result.map(Belt_Result.flatMap(optToRes(Js_json.decodeObject(j), {
                        TAG: /* Failure */0,
                        _0: "an OBJECT",
                        _1: j
                      }), (function (obj) {
                      return Js_dict.entries(obj).reduce((function (acc, param) {
                                    var key = param[0];
                                    if (acc.TAG !== /* Ok */0) {
                                      return acc;
                                    }
                                    var error = Curry._1(aDecoder, param[1]);
                                    if (error.TAG === /* Ok */0) {
                                      return {
                                              TAG: /* Ok */0,
                                              _0: acc._0.concat([[
                                                      key,
                                                      error._0
                                                    ]])
                                            };
                                    } else {
                                      return {
                                              TAG: /* Error */1,
                                              _0: {
                                                TAG: /* Field */2,
                                                _0: key,
                                                _1: error._0
                                              }
                                            };
                                    }
                                  }), {
                                  TAG: /* Ok */0,
                                  _0: []
                                });
                    })), Js_dict.fromArray);
  };
}

function keyValuePairs(aDecoder) {
  return function (j) {
    return Belt_Result.flatMap(optToRes(Js_json.decodeObject(j), {
                    TAG: /* Failure */0,
                    _0: "an OBJECT",
                    _1: j
                  }), (function (obj) {
                  return Js_dict.entries(obj).reduce((function (acc, param) {
                                var key = param[0];
                                if (acc.TAG !== /* Ok */0) {
                                  return acc;
                                }
                                var error = Curry._1(aDecoder, param[1]);
                                if (error.TAG === /* Ok */0) {
                                  return {
                                          TAG: /* Ok */0,
                                          _0: acc._0.concat([[
                                                  key,
                                                  error._0
                                                ]])
                                        };
                                } else {
                                  return {
                                          TAG: /* Error */1,
                                          _0: {
                                            TAG: /* Field */2,
                                            _0: key,
                                            _1: error._0
                                          }
                                        };
                                }
                              }), {
                              TAG: /* Ok */0,
                              _0: []
                            });
                }));
  };
}

function fieldHelp(j, key) {
  return Belt_Result.flatMap(optToRes(Js_json.decodeObject(j), {
                  TAG: /* Failure */0,
                  _0: "an OBJECT with a field named '" + key + "'",
                  _1: j
                }), (function (sObj) {
                return optToRes(Js_dict.get(sObj, key), {
                            TAG: /* Failure */0,
                            _0: "an OBJECT with a field named '" + key + "'",
                            _1: j
                          });
              }));
}

function field(key, aDecoder) {
  return function (j) {
    return Belt_Result.flatMap(fieldHelp(j, key), (function (jv) {
                  return resMapError(Curry._1(aDecoder, jv), (function (e) {
                                return {
                                        TAG: /* Field */2,
                                        _0: key,
                                        _1: e
                                      };
                              }));
                }));
  };
}

function at(firstKey, keys, aDecoder) {
  return function (j) {
    return Belt_Result.flatMap(keys.reduce((function (acc, cur) {
                      if (acc.TAG === /* Ok */0) {
                        return Belt_Result.map(fieldHelp(acc._0[0], cur), (function (ssj) {
                                      return [
                                              ssj,
                                              cur
                                            ];
                                    }));
                      } else {
                        return acc;
                      }
                    }), Belt_Result.map(fieldHelp(j, firstKey), (function (ssj) {
                          return [
                                  ssj,
                                  firstKey
                                ];
                        }))), (function (param) {
                  var key = param[1];
                  return resMapError(Curry._1(aDecoder, param[0]), (function (e) {
                                return {
                                        TAG: /* Field */2,
                                        _0: key,
                                        _1: e
                                      };
                              }));
                }));
  };
}

function index(index$1, aDecoder) {
  return function (j) {
    return Belt_Result.flatMap(Belt_Result.flatMap(optToRes(Js_json.decodeArray(j), {
                        TAG: /* Failure */0,
                        _0: "an ARRAY",
                        _1: j
                      }), (function (arr) {
                      if (arr.length === 0) {
                        return {
                                TAG: /* Error */1,
                                _0: {
                                  TAG: /* Failure */0,
                                  _0: "a NON-EMPTY array. Need index " + String(index$1) + " but only saw an empty array",
                                  _1: j
                                }
                              };
                      } else {
                        return optToRes(Belt_Array.get(arr, index$1), index$1 >= arr.length ? ({
                                        TAG: /* Failure */0,
                                        _0: "a LONGER array. Need index " + String(index$1) + " but only saw " + String(arr.length) + " entries",
                                        _1: j
                                      }) : ({
                                        TAG: /* Failure */0,
                                        _0: "a POSITIVE index. Array has " + String(arr.length) + " entries but tried to decode index " + String(index$1),
                                        _1: j
                                      }));
                      }
                    })), (function (jv) {
                  return resMapError(Curry._1(aDecoder, jv), (function (e) {
                                return {
                                        TAG: /* Index */1,
                                        _0: index$1,
                                        _1: e
                                      };
                              }));
                }));
  };
}

function option(aDecoder) {
  return function (j) {
    return {
            TAG: /* Ok */0,
            _0: Belt_Result.getWithDefault(Belt_Result.map(Curry._1(aDecoder, j), (function (a) {
                        return Caml_option.some(a);
                      })), undefined)
          };
  };
}

function oneOf(firstDecoder, decoders) {
  return function (j) {
    var a = Curry._1(firstDecoder, j);
    if (a.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: a._0
            };
    } else {
      return resMapError(decoders.reduce((function (acc, cur) {
                        if (acc.TAG === /* Ok */0) {
                          return acc;
                        }
                        var match = acc._0;
                        var ne = Curry._1(cur, j);
                        if (ne.TAG === /* Ok */0) {
                          return {
                                  TAG: /* Ok */0,
                                  _0: ne._0
                                };
                        } else {
                          return {
                                  TAG: /* Error */1,
                                  _0: [
                                    match[0],
                                    {
                                      hd: ne._0,
                                      tl: match[1]
                                    }
                                  ]
                                };
                        }
                      }), {
                      TAG: /* Error */1,
                      _0: [
                        a._0,
                        /* [] */0
                      ]
                    }), (function (param) {
                    return {
                            TAG: /* OneOf */3,
                            _0: param[0],
                            _1: Belt_List.toArray(param[1])
                          };
                  }));
    }
  };
}

function fromString(s) {
  try {
    return Caml_option.some(JSON.parse(s));
  }
  catch (exn){
    return ;
  }
}

function decodeString(decoder, s) {
  return Belt_Result.flatMap(optToRes(fromString(s), {
                  TAG: /* Failure */0,
                  _0: "Invalid JSON",
                  _1: s
                }), decoder);
}

function decodeValue(decoder, j) {
  return Curry._1(decoder, j);
}

function errorToString(_e) {
  return "TODO";
}

function map(decoder, f) {
  return function (j) {
    return Belt_Result.map(Curry._1(decoder, j), f);
  };
}

function map2(decoderA, decoderB, f) {
  return function (j) {
    return Belt_Result.flatMap(Curry._1(decoderA, j), (function (a) {
                  return Belt_Result.map(Curry._1(decoderB, j), (function (b) {
                                return Curry._2(f, a, b);
                              }));
                }));
  };
}

function andMap(decoderF, decoderA) {
  return map2(decoderF, decoderA, (function (f, a) {
                return Curry._1(f, a);
              }));
}

function $$null(v) {
  return function (j) {
    return Belt_Result.map(optToRes(Js_json.decodeNull(j), {
                    TAG: /* Failure */0,
                    _0: "invalid null",
                    _1: j
                  }), (function (param) {
                  return v;
                }));
  };
}

function nullable(decoder) {
  var f = function (a) {
    return Caml_option.some(a);
  };
  return oneOf((function (j) {
                return Belt_Result.map(Curry._1(decoder, j), f);
              }), [$$null(undefined)]);
}

function value(j) {
  return {
          TAG: /* Ok */0,
          _0: j
        };
}

function andThen(decoder, f) {
  return function (j) {
    return Belt_Result.flatMap(Curry._1(decoder, j), (function (a) {
                  var b = Curry._1(f, a);
                  return Curry._1(b, j);
                }));
  };
}

function succeed(a) {
  return function (param) {
    return {
            TAG: /* Ok */0,
            _0: a
          };
  };
}

function fail(err) {
  return function (j) {
    return {
            TAG: /* Error */1,
            _0: {
              TAG: /* Failure */0,
              _0: err,
              _1: j
            }
          };
  };
}

function map3(decoderA, decoderB, decoderC, f) {
  return andMap(andMap(andMap((function (param) {
                        return {
                                TAG: /* Ok */0,
                                _0: f
                              };
                      }), decoderA), decoderB), decoderC);
}

function map4(decoderA, decoderB, decoderC, decoderD, f) {
  return andMap(andMap(andMap(andMap((function (param) {
                            return {
                                    TAG: /* Ok */0,
                                    _0: f
                                  };
                          }), decoderA), decoderB), decoderC), decoderD);
}

function map5(decoderA, decoderB, decoderC, decoderD, decoderE, f) {
  return andMap(andMap(andMap(andMap(andMap((function (param) {
                                return {
                                        TAG: /* Ok */0,
                                        _0: f
                                      };
                              }), decoderA), decoderB), decoderC), decoderD), decoderE);
}

function map6(decoderA, decoderB, decoderC, decoderD, decoderE, decoderF, f) {
  return andMap(andMap(andMap(andMap(andMap(andMap((function (param) {
                                    return {
                                            TAG: /* Ok */0,
                                            _0: f
                                          };
                                  }), decoderA), decoderB), decoderC), decoderD), decoderE), decoderF);
}

function map7(decoderA, decoderB, decoderC, decoderD, decoderE, decoderF, decoderG, f) {
  return andMap(andMap(andMap(andMap(andMap(andMap(andMap((function (param) {
                                        return {
                                                TAG: /* Ok */0,
                                                _0: f
                                              };
                                      }), decoderA), decoderB), decoderC), decoderD), decoderE), decoderF), decoderG);
}

function map8(decoderA, decoderB, decoderC, decoderD, decoderE, decoderF, decoderG, decoderH, f) {
  return andMap(andMap(andMap(andMap(andMap(andMap(andMap(andMap((function (param) {
                                            return {
                                                    TAG: /* Ok */0,
                                                    _0: f
                                                  };
                                          }), decoderA), decoderB), decoderC), decoderD), decoderE), decoderF), decoderG), decoderH);
}

exports.string = string;
exports.bool = bool;
exports.$$int = $$int;
exports.$$float = $$float;
exports.nullable = nullable;
exports.array = array;
exports.list = list;
exports.dict = dict;
exports.keyValuePairs = keyValuePairs;
exports.field = field;
exports.at = at;
exports.index = index;
exports.option = option;
exports.oneOf = oneOf;
exports.decodeString = decodeString;
exports.decodeValue = decodeValue;
exports.errorToString = errorToString;
exports.map = map;
exports.map2 = map2;
exports.map3 = map3;
exports.map4 = map4;
exports.map5 = map5;
exports.map6 = map6;
exports.map7 = map7;
exports.map8 = map8;
exports.andMap = andMap;
exports.$$null = $$null;
exports.value = value;
exports.andThen = andThen;
exports.succeed = succeed;
exports.fail = fail;
/* No side effect */
